#include <fstream>
#include <string>
#include <assert.h>
#include <unordered_map>
#include <vector>
#include <set>
#include "cache.h"
#include "prefetcher.h"

/* Supported prefetchers at LLC */
#include "sms.h"
#include "scooby.h"
#include "next_line.h"
#include "bop.h"
#include "sandbox.h"
#include "dspatch.h"
#include "spp_dev2.h"
//#include "ppf_dev.h"
//#include "mlop.h" // FIXME: Gives segfault
#include "bingo.h"
#include "stride.h"
#include "ampm.h"
#include "streamer.h"
#include "pref_power7.h"
#include "sisb.h"
//#include "triage.h"  // FIXME: Gives assertion error

using namespace std;

namespace knob
{
    // Automatically pick the LLC prefetcher types based on what is inside the pc_trace.
    extern bool           spp_dev2_pf_llc_only;
    extern bool           bingo_pf_llc_only;
    extern string         pc_trace_llc;
    
    // Prefetcher degree knobs, for setting default degree (others are unsupported for now.)
    extern uint32_t sms_pref_degree;
    extern uint32_t spp_pref_degree;
    extern uint32_t bop_pref_degree;
    extern uint32_t sisb_pref_degree;
}


/* Per-PC and prefetcher data */
unordered_map<uint64_t, vector<string>> pc_prefetchers; // PC -> Prefetchers    : Prefetchers to use on each PC
unordered_map<uint64_t, vector<uint64_t>> pc_degrees;   // PC -> Degrees        : Degrees to use on each PC (0 = use default degree / no degree)
unordered_map<string, uint32_t> default_pref_degrees;   // Prefetcher -> Degree : Original values of each prefetcher's degree knob.
set<string> prefetcher_names;                           // Prefetchers          : Set of prefetchers to load, based on those that appear in the trace.


/* Shadow Cache (infinite size) */
struct ShadowEntry {
    uint64_t address;
    uint64_t insertion_time;   // Insertion time (after this cycle, we assume the prefetch was "filled")
    bool real_prefetch = false; // If this was a real prefetch.
};
unordered_map<string, unordered_map<uint64_t, ShadowEntry>> shadow_cache; // Prefetcher -> (Address -> Entry) : Per-prefetcher shadow cache to insert prefetches.


/* Statistics */
int not_prefetched = 0; // Number of prefetch queries where the PC wasn't found.
int prefetched = 0;     // Number of prefetch queries where the PC was found.


/* Helper functions */
void parse_pc_trace() {
    // Open PC trace file
    ifstream pc_trace;
    pc_trace = ifstream(knob::pc_trace_llc);
    assert(pc_trace.is_open());
    
    uint64_t pc;
    string line;
    string token;
    
    while(getline(pc_trace, line)) {
        stringstream line_stream(line); 
        
        for(int i = 0; i < 3; i++) { // Parse line (format: `pc pref1,pref2,...,prefn deg1,deg2,...,degn`)
            getline(line_stream, token, ' ');
            stringstream token_stream(token);
            
            if (i == 0) {  // Get PC   
                pc = stol(token, nullptr, 16); 
            } else if (i == 1) {  // Get prefetchers
                string pref;
                while (getline(token_stream, pref, ',')) {
                    pc_prefetchers[pc].push_back(pref);
                    prefetcher_names.insert(pref);
                }
            } else if (i == 2) { // Get degrees
                string deg_str;
                uint64_t deg;
                while (getline(token_stream, deg_str, ',')) {
                    if (deg_str == "na")
                        deg = 0; // Just use default degree (either via knobs or default setting.)
                    else deg = stol(deg_str);
                    pc_degrees[pc].push_back(deg);
                }
            }
        }
        
        // cout << "[DEBUG] pc=" << hex << pc 
        //      << " prefs[0]=" << pc_prefetchers[pc][0] 
        //      << " degrees[0]=" << dec << pc_degrees[pc][0] << endl;
    }
    pc_trace.close();
}

void add_prefetchers(CACHE *cache, vector<Prefetcher*> &prefetchers) {
    /* Initialize prefetchers, and add them to the prefetchers vector */
	for(auto pref : prefetcher_names)
	{
		if(!pref.compare("none"))
		{
			cout << "adding LLC_PREFETCHER: NONE" << endl;
		}
		else if(!pref.compare("sms"))
		{
			cout << "adding LLC_PREFETCHER: SMS" << endl;
			SMSPrefetcher *pref_sms = new SMSPrefetcher(pref);
			prefetchers.push_back(pref_sms);
            default_pref_degrees["sms"] = knob::sms_pref_degree;
		}
		else if(!pref.compare("bop"))
		{
			cout << "adding LLC_PREFETCHER: BOP" << endl;
			BOPrefetcher *pref_bop = new BOPrefetcher(pref);
			prefetchers.push_back(pref_bop);
            default_pref_degrees["bop"] = knob::bop_pref_degree;
		}
		else if(!pref.compare("dspatch"))
		{
			cout << "adding LLC_PREFETCHER: DSPatch" << endl;
			DSPatch *pref_dspatch = new DSPatch(pref);
			prefetchers.push_back(pref_dspatch);
		}
		else if(!pref.compare("scooby"))
		{
			cout << "adding LLC_PREFETCHER: Scooby" << endl;
			Scooby *pref_scooby = new Scooby(pref);
			prefetchers.push_back(pref_scooby);
		}
		else if(!pref.compare("next_line"))
		{
			cout << "adding LLC_PREFETCHER: next_line" << endl;
			NextLinePrefetcher *pref_nl = new NextLinePrefetcher(pref);
			prefetchers.push_back(pref_nl);
		}
		else if(!pref.compare("sandbox"))
		{
			cout << "adding LLC_PREFETCHER: Sandbox" << endl;
			SandboxPrefetcher *pref_sandbox = new SandboxPrefetcher(pref);
			prefetchers.push_back(pref_sandbox);
		}
		else if(!pref.compare("spp_dev2"))
		{
            assert(knob::spp_dev2_pf_llc_only); // Can't prefetch to L2 if spp_dev2 operating in LLC. (knob must be true)
			cout << "adding LLC_PREFETCHER: SPP_dev2" << endl;
			SPP_dev2 *pref_spp_dev2 = new SPP_dev2(pref, cache);
			prefetchers.push_back(pref_spp_dev2);
            default_pref_degrees["spp_dev2"] = knob::spp_pref_degree;
		}
		// else if(!pref.compare("spp_ppf_dev"))
		// {
		// 	cout << "adding LLC_PREFETCHER: SPP_PPF_dev" << endl;
		// 	SPP_PPF_dev *pref_spp_ppf_dev = new SPP_PPF_dev(pref, this);
		// 	prefetchers.push_back(pref_spp_ppf_dev);
		// }
		// else if(!pref.compare("mlop"))
		// {
		// 	cout << "adding LLC_PREFETCHER: MLOP" << endl;
		// 	MLOP *pref_mlop = new MLOP(pref, this);
		// 	prefetchers.push_back(pref_mlop);
		// }
		else if(!pref.compare("bingo"))
		{
            assert(knob::bingo_pf_llc_only); // Can't prefetch to L2 if Bingo operating in LLC. (knob must be true)
			cout << "adding LLC_PREFETCHER: Bingo" << endl;
			Bingo *pref_bingo = new Bingo(pref, cache);
			prefetchers.push_back(pref_bingo);
		}
		else if(!pref.compare("stride"))
		{
			cout << "adding LLC_PREFETCHER: Stride" << endl;
			StridePrefetcher *pref_stride = new StridePrefetcher(pref);
			prefetchers.push_back(pref_stride);
		}
		else if (!pref.compare("streamer"))
		{
			cout << "adding LLC_PREFETCHER: streamer" << endl;
			Streamer *pref_streamer = new Streamer(pref);
			prefetchers.push_back(pref_streamer);
		}
		else if (!pref.compare("power7"))
		{
			cout << "adding LLC_PREFETCHER: POWER7" << endl;
			POWER7_Pref *pref_power7 = new POWER7_Pref(pref, cache);
			prefetchers.push_back(pref_power7);
		}
		else if (!pref.compare("ampm"))
		{
			cout << "adding LLC_PREFETCHER: AMPM" << endl;
			AMPM *pref_ampm = new AMPM(pref);
			prefetchers.push_back(pref_ampm);
		}
        else if (!pref.compare("sisb"))
		{
			cout << "adding LLC_PREFETCHER: SISB" << endl;
			SISBPrefetcher *pref_sisb = new SISBPrefetcher(pref);
			prefetchers.push_back(pref_sisb);
            default_pref_degrees["sisb"] = knob::sisb_pref_degree;
		}
		// else if (!pref.compare("triage"))
		// {
		// 	cout << "adding LLC_PREFETCHER: TRIAGE" << endl;
		// 	TriagePrefetcher *pref_triage = new TriagePrefetcher(pref, this);
		// 	prefetchers.push_back(pref_triage);
		// }
		else
		{
			cout << "unsupported prefetcher type " << pref << endl;
			exit(1);
		}
	}

	assert(prefetcher_names.size() == prefetchers.size());
}

bool does_prefetch_pc(string prefetcher_name, uint64_t pc) {
    for (auto pref : pc_prefetchers[pc]) {
          if (prefetcher_name == pref)
              return true;
    }
    return false;
}

void set_prefetch_degree(uint64_t pc) {
    /* Set the prefetch degree of the prefetchers targeted by the PC */
    for (int i = 0; i < pc_prefetchers[pc].size(); i++) {
        if (pc_prefetchers[pc][i] == "sms") {
            knob::sms_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["sms"];
        } else if (pc_prefetchers[pc][i] == "spp_dev2") {
            knob::spp_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["spp_dev2"]; // SPP degree knob doesn't do anything.
        } else if (pc_prefetchers[pc][i] == "bop") {
            knob::bop_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["bop"];
        } else if (pc_prefetchers[pc][i] == "sisb") {
            knob::sisb_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["sisb"];
        }
    }
}

void reset_prefetch_degree() {
    knob::sms_pref_degree = default_pref_degrees["sms"];
    knob::spp_pref_degree = default_pref_degrees["spp_dev2"]; // SPP degree knob doesn't do anything.
    knob::bop_pref_degree = default_pref_degrees["bop"];
    knob::sisb_pref_degree = default_pref_degrees["sisb"];
}


/* Class functions */
void CACHE::llc_prefetcher_initialize()
{
    parse_pc_trace();
    add_prefetchers(this, prefetchers);  
}

// Under multi_pc_trace, all prefetchers operate, but 
// only the prefetchers associated with the PC / IP get to
// actually issue the prefetch.
//
// If the PC isn't in the pc_prefetch table, issue no prefetch.
uint32_t CACHE::llc_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in, uint64_t instr_id, uint64_t curr_cycle)
{
    // Set prefetcher degrees (for those that issue a prefetch on this PC)
    set_prefetch_degree(ip);
    // cout << "[DEBUG] llc_prefetcher_operate"
    //      << " addr=" << hex << addr
    //      << " ip=" << hex << ip
    //      << " cache_hit=" << dec << cache_hit
    //      << " type=" << dec << type
    //      << " metadata_in=" << dec << metadata_in
    //      << " instr_id=" << dec << instr_id
    //      << " curr_cycle=" << dec << curr_cycle 
    //      << endl;
    
    // Log query_prefetched, query_not_prefetch stats
    if (pc_prefetchers[ip].size() == 0)
        not_prefetched++;
    else prefetched++;
    
    
    unordered_map<string, vector<uint64_t>> pref_addrs;
    unordered_map<string, vector<uint64_t>> pref_levels;
    
    vector<uint64_t> real_pref_addrs;  // Addresses for all real prefetches
    vector<uint64_t> real_pref_levels; // Levels for all real prefetches
    
    // Invoke all prefetchers
    // Issue the PC's prefetchers to the cache ("real" prefetches).
    // Don't issue other prefetchers to the cache ("fake" prefetches).
    for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
        string pref = prefetchers[index]->get_type();
        
        // Invoke all prefetchers
        prefetchers[index]->invoke_prefetcher(ip, addr, cache_hit, type, pref_addrs[pref], pref_levels[pref]);
        
        // Loop through the prefetches.
        // - Add each prefetch to the shadow cache. (TODO: Level prefetching support)
        // - If the PC is using this prefetcher, issue each prefetch to the REAL cache.
        //
        // Other prefetchers will *think* they issued the prefetch,
        // but it will have no effect in the real cache. 
        for (uint32_t addr_index = 0; addr_index < pref_addrs[pref].size(); addr_index++) {
            if (does_prefetch_pc(pref, ip)) {
                uint64_t target_addr = pref_addrs[pref][addr_index];
                uint64_t target_level = (pref_levels[pref][addr_index] == 0 ? FILL_LLC : pref_levels[pref][addr_index]);
                
                uint32_t pf_metadata = 0;
                prefetch_line(ip, addr, target_addr, target_level, pf_metadata);
                
                real_pref_addrs.push_back(target_addr);
                real_pref_levels.push_back(target_level);
            }
        }
	}
    
    // Create shadow cache entires for each prefetcher.
    // "Real" if the address was prefetched by one of the PC's prefetchers.
    // "Fake" otherwise.
    for(uint32_t index = 0; index < prefetchers.size(); ++index)
    {
        //cout << "[DEBUG] Initializing shadow entry" << endl;
        string pref = prefetchers[index]->get_type();
        
        // Loop through the prefetches.
        for (uint32_t addr_index = 0; addr_index < pref_addrs[pref].size(); addr_index++) {    
            uint64_t target_addr = pref_addrs[pref][addr_index];
            
            shadow_cache[pref][target_addr] = ShadowEntry();
            shadow_cache[pref][target_addr].address        = target_addr;
            shadow_cache[pref][target_addr].insertion_time = curr_cycle;
            shadow_cache[pref][target_addr].real_prefetch  = (find(real_pref_addrs.begin(), real_pref_addrs.end(), target_addr) != real_pref_addrs.end());
        }
    }
    
    
    		
    // Reset prefetcher degrees
    reset_prefetch_degree();

	return metadata_in;
}


void register_fill(vector<Prefetcher*> prefetchers, string pref, uint64_t addr, uint32_t set, uint32_t way,
                   uint8_t prefetch, uint64_t evicted_addr) 
    /* Register a fill, regardless of whether it's from a real or fake prefetch. */
{
    auto pref_obj = find_if(prefetchers.begin(), prefetchers.end(), [=](Prefetcher* p) {return p->get_type() == pref;} );
    
    // TODO get index of the prefetcher
    if(pref == "scooby")
    {
        Scooby *pref_scooby = (Scooby*)*pref_obj;
        pref_scooby->register_fill(addr);
    }
    else if(pref == "next_line")
    {
        NextLinePrefetcher *pref_nl = (NextLinePrefetcher*)*pref_obj;
        pref_nl->register_fill(addr);
    }
    else if(pref == "bop")
    {
        BOPrefetcher *pref_bop = (BOPrefetcher*)*pref_obj;
        pref_bop->register_fill(addr);
    }
    else if(pref == "spp_dev2")
    {
        SPP_dev2 *pref_spp_dev2 = (SPP_dev2*)*pref_obj;
        pref_spp_dev2->cache_fill(addr, set, way, prefetch, evicted_addr);
    }
    //else if(pref == "spp_ppf_dev")
    //{
    //	SPP_PPF_dev *pref_spp_ppf_dev = (SPP_PPF_dev*)*pref_obj;
    //	pref_spp_ppf_dev->cache_fill(addr, set, way, prefetch, evicted_addr);
    //}
    //else if(pref == "mlop")
    //{
    //  MLOP *pref_mlop = (MLOP*)prefetchers[index];
    // 	pref_mlop->register_fill(addr, set, way, prefetch, evicted_addr);
    //}
    else if(pref == "bingo")
    {
        Bingo *pref_bingo = (Bingo*)*pref_obj;
        pref_bingo->register_fill(addr, set, way, prefetch, evicted_addr);
    }
    else if(pref == "sisb")
    {
        SISBPrefetcher *pref_sisb = (SISBPrefetcher*)*pref_obj;
        pref_sisb->register_fill(addr);
    }
    //else if(pref == "triage")
    //{
    //	TriagePrefetcher *pref_triage = (TriagePrefetcher*)*pref_obj;
    //	pref_triage->register_fill(addr, prefetch, metadata_in);
    //}
}


// Note: This is called on *every* cache fill, so we also can watch for replacements! (for online statistics)
uint32_t CACHE::llc_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    
	if(prefetch)
	{
        // cout << "[DEBUG] llc_prefetcher_cache_fill" 
        //      << " addr=" << hex << addr
        //      << " metadata_in=" << dec << metadata_in 
        //      << endl;
		for(uint32_t index = 0; index < prefetchers.size(); ++index)
		{
            string pref = prefetchers[index]->get_type();
            if (shadow_cache[pref].find(addr) != shadow_cache[pref].end()) {
                // [DEBUG]
                // if(shadow_cache[pref][addr].real_prefetch) {
                //    cout << "[DEBUG] FOUND in shadow_cache"
                //         << " pref=" << pref 
                //         << " addr=" << hex << addr
                //         << " age_cycles=" << dec << current_core_cycle[cpu] - shadow_cache[pref][addr].insertion_time
                //         << " evicted_addr=" << hex << evicted_addr
                //         << " real_prefetch=" << dec << shadow_cache[pref][addr].real_prefetch
                //         << endl;
                // }
                
                // Register a real prefetch.
                // Inform ALL prefetchers that did (or would have) prefetched the address.
                register_fill(prefetchers, pref, addr, set, way, prefetch, evicted_addr); 
                shadow_cache[pref].erase(addr);                              // Erase the shadow cache entry (not needed anymore)
            }
		}
	}

	return metadata_in;
}

void CACHE::llc_prefetcher_cycle_operate() 
{
//     uint64_t DELTA = 16; // Number of cycles to wait before registering a fake fill. TODO: Make knob, or automatic
//     uint64_t curr_cycle = current_core_cycle[cpu];
    
//     // For all fake prefetches, register the fake fill DELTA cycles after
//     // it was requested by one of the prefetchers.
//     //
//     // Real prefetches wait until they're really filled by the cache.
    
//     //cout << "[DEBUG] llc_prefetcher_cycle_operate cycle=" << dec << current_core_cycle[cpu] << endl;
//     for (auto pref : shadow_cache) {
//         string pref_name = pref.first;
//         auto it = pref.second.begin();
//         //int i = 0;
//         while(it != pref.second.end()) {
            
//             //cout << "DEBUG inside it i=" << dec << i << endl;
//             //i++;
                
//             ShadowEntry se = it->second;
            
//             if (!se.real_prefetch && se.insertion_time > curr_cycle + DELTA) {
//                 register_fill(prefetchers, pref_name, se.address, 0, 0, 1, 0); // Fake fill (will remove entry for us)         
//                 it = pref.second.erase(it);
//             } else {
//                 it++;
//             }
//         }
//     } 
}


uint32_t CACHE::llc_prefetcher_prefetch_hit(uint64_t addr, uint64_t ip, uint32_t metadata_in)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
        for (auto pref : pc_prefetchers[ip]) {
            if(!pref.compare("scooby") && !prefetchers[index]->get_type().compare("scooby")) {
                Scooby *pref_scooby = (Scooby*)prefetchers[index];
                pref_scooby->register_prefetch_hit(addr);
            }
        }
	}

    return metadata_in;
}

void CACHE::llc_prefetcher_final_stats()
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		prefetchers[index]->dump_stats();
	}
    
    cout << "multi_pc_trace stats" << endl
         << "queries_not_prefetched " << not_prefetched << endl
         << "queries_prefetched " << prefetched << endl << endl;
}

void CACHE::llc_prefetcher_print_config()
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		prefetchers[index]->print_config();
	}
}

void CACHE::llc_prefetcher_broadcast_bw(uint8_t bw_level)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
        if(!prefetchers[index]->get_type().compare("scooby"))
        {
            Scooby *pref_scooby = (Scooby*)prefetchers[index];
            pref_scooby->update_bw(bw_level);
        }
        if(!prefetchers[index]->get_type().compare("dspatch"))
        {
            DSPatch *pref_dspatch = (DSPatch*)prefetchers[index];
            pref_dspatch->update_bw(bw_level);
        }
	}
}

void CACHE::llc_prefetcher_broadcast_ipc(uint8_t ipc)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		if(!prefetchers[index]->get_type().compare("scooby"))
		{
			Scooby *pref_scooby = (Scooby*)prefetchers[index];
			pref_scooby->update_ipc(ipc);
		}
	}
}

void CACHE::llc_prefetcher_broadcast_acc(uint32_t acc_level)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		if(!prefetchers[index]->get_type().compare("scooby"))
		{
			Scooby *pref_scooby = (Scooby*)prefetchers[index];
			pref_scooby->update_acc(acc_level);
		}
	}
}
