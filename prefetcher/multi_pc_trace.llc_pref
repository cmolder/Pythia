#include <fstream>
#include <string>
#include <assert.h>
#include <unordered_map>
#include <vector>
#include <set>
#include "cache.h"
#include "prefetcher.h"

/* Supported prefetchers at LLC */
#include "sms.h"
#include "scooby.h"
#include "next_line.h"
#include "bop.h"
#include "sandbox.h"
#include "dspatch.h"
#include "spp_dev2.h"
//#include "ppf_dev.h"
//#include "mlop.h" // FIXME: Gives segfault
#include "bingo.h"
#include "stride.h"
#include "ampm.h"
#include "streamer.h"
#include "pref_power7.h"
#include "sisb.h"
//#include "triage.h"  // FIXME: Gives assertion error

using namespace std;

namespace knob
{
    // Automatically pick the LLC prefetcher types based on what is inside the pc_trace.
    extern bool           spp_dev2_pf_llc_only;
    extern bool           bingo_pf_llc_only;
    extern string         pc_trace_llc;
    
    // Prefetcher degree knobs, for setting default degree (others are unsupported for now.)
    extern uint32_t sms_pref_degree;
    extern uint32_t spp_pref_degree;
    extern uint32_t bop_pref_degree;
    extern uint32_t sisb_pref_degree;
}

/* Per-PC and prefetcher data */
unordered_map<uint64_t, vector<string>> pc_prefetchers; // Prefetchers to use on each PC
unordered_map<uint64_t, vector<uint64_t>> pc_degrees;   // Degrees to use on each PC (0 = use default degree / no degree)
unordered_map<string, uint32_t> default_pref_degrees;   // Original values of each prefetcher's degree knob.
set<string> prefetcher_names;                           // Set of prefetchers to load, based on those that appear in the trace.

/* Statistics */
int not_prefetched = 0; // Number of prefetch queries where the PC wasn't found.
int prefetched = 0;     // Number of prefetch queries where the PC was found.

/* Helper functions */
void parse_pc_trace() {
    // Open PC trace file
    ifstream pc_trace;
    pc_trace = ifstream(knob::pc_trace_llc);
    assert(pc_trace.is_open());
    
    uint64_t pc;
    string line;
    string token;
    
    while(getline(pc_trace, line)) {
        stringstream line_stream(line); 
        
        for(int i = 0; i < 3; i++) { // Parse line (format: `pc pref1,pref2,...,prefn deg1,deg2,...,degn`)
            getline(line_stream, token, ' ');
            stringstream token_stream(token);
            
            if (i == 0) {  // Get PC   
                pc = stoi(token, nullptr, 16); 
            } else if (i == 1) {  // Get prefetchers
                string pref;
                while (getline(token_stream, pref, ',')) {
                    pc_prefetchers[pc].push_back(pref);
                    prefetcher_names.insert(pref);
                }
            } else if (i == 2) { // Get degrees
                string deg_str;
                uint64_t deg;
                while (getline(token_stream, deg_str, ',')) {
                    if (deg_str == "na")
                        deg = 0; // Just use default degree (either via knobs or default setting.)
                    else deg = stoi(deg_str);
                    pc_degrees[pc].push_back(deg);
                }
            }
        }
        
        // cout << "[DEBUG] pc=" << hex << pc 
        //      << " prefs[0]=" << pc_prefetchers[pc][0] 
        //      << " degrees[0]=" << dec << pc_degrees[pc][0] << endl;
    }
    pc_trace.close();
}

void add_prefetchers(CACHE *cache, vector<Prefetcher*> &prefetchers) {
    /* Initialize prefetchers, and add them to the prefetchers vector */
	for(auto pref : prefetcher_names)
	{
		if(!pref.compare("none"))
		{
			cout << "adding LLC_PREFETCHER: NONE" << endl;
		}
		else if(!pref.compare("sms"))
		{
			cout << "adding LLC_PREFETCHER: SMS" << endl;
			SMSPrefetcher *pref_sms = new SMSPrefetcher(pref);
			prefetchers.push_back(pref_sms);
            default_pref_degrees["sms"] = knob::sms_pref_degree;
		}
		else if(!pref.compare("bop"))
		{
			cout << "adding LLC_PREFETCHER: BOP" << endl;
			BOPrefetcher *pref_bop = new BOPrefetcher(pref);
			prefetchers.push_back(pref_bop);
            default_pref_degrees["bop"] = knob::bop_pref_degree;
		}
		else if(!pref.compare("dspatch"))
		{
			cout << "adding LLC_PREFETCHER: DSPatch" << endl;
			DSPatch *pref_dspatch = new DSPatch(pref);
			prefetchers.push_back(pref_dspatch);
		}
		else if(!pref.compare("scooby"))
		{
			cout << "adding LLC_PREFETCHER: Scooby" << endl;
			Scooby *pref_scooby = new Scooby(pref);
			prefetchers.push_back(pref_scooby);
		}
		else if(!pref.compare("next_line"))
		{
			cout << "adding LLC_PREFETCHER: next_line" << endl;
			NextLinePrefetcher *pref_nl = new NextLinePrefetcher(pref);
			prefetchers.push_back(pref_nl);
		}
		else if(!pref.compare("sandbox"))
		{
			cout << "adding LLC_PREFETCHER: Sandbox" << endl;
			SandboxPrefetcher *pref_sandbox = new SandboxPrefetcher(pref);
			prefetchers.push_back(pref_sandbox);
		}
		else if(!pref.compare("spp_dev2"))
		{
            assert(knob::spp_dev2_pf_llc_only); // Can't prefetch to L2 if spp_dev2 operating in LLC. (knob must be true)
			cout << "adding LLC_PREFETCHER: SPP_dev2" << endl;
			SPP_dev2 *pref_spp_dev2 = new SPP_dev2(pref, cache);
			prefetchers.push_back(pref_spp_dev2);
            default_pref_degrees["spp_dev2"] = knob::spp_pref_degree;
		}
		// else if(!pref.compare("spp_ppf_dev"))
		// {
		// 	cout << "adding LLC_PREFETCHER: SPP_PPF_dev" << endl;
		// 	SPP_PPF_dev *pref_spp_ppf_dev = new SPP_PPF_dev(pref, this);
		// 	prefetchers.push_back(pref_spp_ppf_dev);
		// }
		// else if(!pref.compare("mlop"))
		// {
		// 	cout << "adding LLC_PREFETCHER: MLOP" << endl;
		// 	MLOP *pref_mlop = new MLOP(pref, this);
		// 	prefetchers.push_back(pref_mlop);
		// }
		else if(!pref.compare("bingo"))
		{
            assert(knob::bingo_pf_llc_only); // Can't prefetch to L2 if Bingo operating in LLC. (knob must be true)
			cout << "adding LLC_PREFETCHER: Bingo" << endl;
			Bingo *pref_bingo = new Bingo(pref, cache);
			prefetchers.push_back(pref_bingo);
		}
		else if(!pref.compare("stride"))
		{
			cout << "adding LLC_PREFETCHER: Stride" << endl;
			StridePrefetcher *pref_stride = new StridePrefetcher(pref);
			prefetchers.push_back(pref_stride);
		}
		else if (!pref.compare("streamer"))
		{
			cout << "adding LLC_PREFETCHER: streamer" << endl;
			Streamer *pref_streamer = new Streamer(pref);
			prefetchers.push_back(pref_streamer);
		}
		else if (!pref.compare("power7"))
		{
			cout << "adding LLC_PREFETCHER: POWER7" << endl;
			POWER7_Pref *pref_power7 = new POWER7_Pref(pref, cache);
			prefetchers.push_back(pref_power7);
		}
		else if (!pref.compare("ampm"))
		{
			cout << "adding LLC_PREFETCHER: AMPM" << endl;
			AMPM *pref_ampm = new AMPM(pref);
			prefetchers.push_back(pref_ampm);
		}
        else if (!pref.compare("sisb"))
		{
			cout << "adding LLC_PREFETCHER: SISB" << endl;
			SISBPrefetcher *pref_sisb = new SISBPrefetcher(pref);
			prefetchers.push_back(pref_sisb);
            default_pref_degrees["sisb"] = knob::sisb_pref_degree;
		}
		// else if (!pref.compare("triage"))
		// {
		// 	cout << "adding LLC_PREFETCHER: TRIAGE" << endl;
		// 	TriagePrefetcher *pref_triage = new TriagePrefetcher(pref, this);
		// 	prefetchers.push_back(pref_triage);
		// }
		else
		{
			cout << "unsupported prefetcher type " << pref << endl;
			exit(1);
		}
	}

	assert(prefetcher_names.size() == prefetchers.size());
}

bool does_prefetch_pc(string prefetcher_name, uint64_t pc) {
    for (auto pref : pc_prefetchers[pc]) {
          if (prefetcher_name == pref)
              return true;
    }
    return false;
}

void set_prefetch_degree(uint64_t pc) {
    /* Set the prefetch degree of the prefetchers targeted by the PC */
    for (int i = 0; i < pc_prefetchers[pc].size(); i++) {
        if (pc_prefetchers[pc][i] == "sms") {
            knob::sms_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["sms"];
        } else if (pc_prefetchers[pc][i] == "spp_dev2") {
            knob::spp_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["spp_dev2"]; // SPP degree knob doesn't do anything.
        } else if (pc_prefetchers[pc][i] == "bop") {
            knob::bop_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["bop"];
        } else if (pc_prefetchers[pc][i] == "sisb") {
            knob::sisb_pref_degree = pc_degrees[pc][i] > 0 ? pc_degrees[pc][i] : default_pref_degrees["sisb"];
        }
    }
}

void reset_prefetch_degree() {
    knob::sms_pref_degree = default_pref_degrees["sms"];
    knob::spp_pref_degree = default_pref_degrees["spp_dev2"]; // SPP degree knob doesn't do anything.
    knob::bop_pref_degree = default_pref_degrees["bop"];
    knob::sisb_pref_degree = default_pref_degrees["sisb"];
}

void CACHE::llc_prefetcher_initialize()
{
    parse_pc_trace();
    add_prefetchers(this, prefetchers);  
}

// Under multi_pc_trace, all prefetchers operate, but 
// only the prefetchers associated with the PC / IP get to
// actually issue the prefetch.
//
// If the PC isn't in the pc_prefetch table, issue no prefetch.
uint32_t CACHE::llc_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
	vector<uint64_t> pref_addr;
    vector<uint64_t> pref_level;
    
    // Set prefetcher degrees (for those that issue a prefetch on this PC)
    set_prefetch_degree(ip);
    
    for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
        string pref_name = prefetchers[index]->get_type();
        
        // Invoke the prefetcher
        //if(true) {                            // All prefetchers
        if(does_prefetch_pc(pref_name, ip)) { // Only those for this PC
        //if(pref_name == ?? || does_prefetch_pc(pref_name, ip)) { // Only those for this PC, or those whose logic isn't PC localized + doesn't depend on fills.
            prefetchers[index]->invoke_prefetcher(ip, addr, cache_hit, type, pref_addr, pref_level);
        }

        // Log query_prefetched, query_not_prefetch stats
        if (pc_prefetchers[ip].size() == 0)
            not_prefetched++;
        else prefetched++;
        
        // Issue prefetches, if the PC is using this prefetcher.
        //
        // Other prefetchers will *think* they issued the prefetch,
        // but it will have no effect in the real cache.
        if (does_prefetch_pc(pref_name, ip)) {
            for (uint32_t addr_index = 0; addr_index < pref_addr.size(); addr_index++) {
                prefetch_line(ip, addr, pref_addr[addr_index], (pref_level[addr_index] == 0 ? FILL_LLC : pref_level[addr_index]), 0);
            }
        } else {
            // TODO : Inform the non-assigned prefetchers of a fill?
            // Scooby, SMS, Bingo, BOP, and possibly some others use fills to update their logic (see above).
            // Maybe implement a per-prefetcher ATD that tracks the cache it would have had.
        }
        
        // Clear address / level vectors
		pref_addr.clear();
        pref_level.clear();
	}
    		
    // Reset prefetcher degrees
    reset_prefetch_degree();

	return metadata_in;
}

// TODO: Need to inform prefetchers of their shadow prefetches.
uint32_t CACHE::llc_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
	if(prefetch)
	{
		for(uint32_t index = 0; index < prefetchers.size(); ++index)
		{
			if(!prefetchers[index]->get_type().compare("scooby"))
			{
				Scooby *pref_scooby = (Scooby*)prefetchers[index];
				pref_scooby->register_fill(addr);
			}
			if(!prefetchers[index]->get_type().compare("next_line"))
			{
				NextLinePrefetcher *pref_nl = (NextLinePrefetcher*)prefetchers[index];
				pref_nl->register_fill(addr);
			}
			if(!prefetchers[index]->get_type().compare("bop"))
			{
				BOPrefetcher *pref_bop = (BOPrefetcher*)prefetchers[index];
				pref_bop->register_fill(addr);
			}
			if(!prefetchers[index]->get_type().compare("spp_dev2"))
			{
				SPP_dev2 *pref_spp_dev2 = (SPP_dev2*)prefetchers[index];
				pref_spp_dev2->cache_fill(addr, set, way, prefetch, evicted_addr);
			}
			//if(!prefetchers[index]->get_type().compare("spp_ppf_dev"))
			//{
			//	SPP_PPF_dev *pref_spp_ppf_dev = (SPP_PPF_dev*)prefetchers[index];
			//	pref_spp_ppf_dev->cache_fill(addr, set, way, prefetch, evicted_addr);
			//}
			// if(!prefetchers[index]->get_type().compare("mlop"))
			// {
			// 	MLOP *pref_mlop = (MLOP*)prefetchers[index];
			// 	pref_mlop->register_fill(addr, set, way, prefetch, evicted_addr);
			// }
			if(!prefetchers[index]->get_type().compare("bingo"))
			{
				Bingo *pref_bingo = (Bingo*)prefetchers[index];
				pref_bingo->register_fill(addr, set, way, prefetch, evicted_addr);
			}
            if(!prefetchers[index]->get_type().compare("sisb"))
			{
				SISBPrefetcher *pref_sisb = (SISBPrefetcher*)prefetchers[index];
				pref_sisb->register_fill(addr);
			}
			// if(!prefetchers[index]->get_type().compare("triage"))
			// {
			// 	TriagePrefetcher *pref_triage = (TriagePrefetcher*)prefetchers[index];
			// 	pref_triage->register_fill(addr, prefetch, metadata_in);
			// }
		}
	}

	return metadata_in;
}

uint32_t CACHE::llc_prefetcher_prefetch_hit(uint64_t addr, uint64_t ip, uint32_t metadata_in)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
        for (auto pref : pc_prefetchers[ip]) {
            if(!pref.compare("scooby") && !prefetchers[index]->get_type().compare("scooby")) {
                Scooby *pref_scooby = (Scooby*)prefetchers[index];
                pref_scooby->register_prefetch_hit(addr);
            }
        }
	}

    return metadata_in;
}

void CACHE::llc_prefetcher_final_stats()
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		prefetchers[index]->dump_stats();
	}
    
    cout << "multi_pc_trace stats" << endl
         << "queries_not_prefetched " << not_prefetched << endl
         << "queries_prefetched " << prefetched << endl << endl;
}

void CACHE::llc_prefetcher_print_config()
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		prefetchers[index]->print_config();
	}
}

void CACHE::llc_prefetcher_broadcast_bw(uint8_t bw_level)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
        if(!prefetchers[index]->get_type().compare("scooby"))
        {
            Scooby *pref_scooby = (Scooby*)prefetchers[index];
            pref_scooby->update_bw(bw_level);
        }
        if(!prefetchers[index]->get_type().compare("dspatch"))
        {
            DSPatch *pref_dspatch = (DSPatch*)prefetchers[index];
            pref_dspatch->update_bw(bw_level);
        }
	}
}

void CACHE::llc_prefetcher_broadcast_ipc(uint8_t ipc)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		if(!prefetchers[index]->get_type().compare("scooby"))
		{
			Scooby *pref_scooby = (Scooby*)prefetchers[index];
			pref_scooby->update_ipc(ipc);
		}
	}
}

void CACHE::llc_prefetcher_broadcast_acc(uint32_t acc_level)
{
	for(uint32_t index = 0; index < prefetchers.size(); ++index)
	{
		if(!prefetchers[index]->get_type().compare("scooby"))
		{
			Scooby *pref_scooby = (Scooby*)prefetchers[index];
			pref_scooby->update_acc(acc_level);
		}
	}
}
